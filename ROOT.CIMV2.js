/**
 * @file Modification of the Management Classes generated by mgmclassgen.exe.
 * @version 0.0.1
 */
import System;
import System.Management;
import System.Diagnostics;
import System.Reflection;

[assembly: AssemblyTitle('WIM Utilities')]

package ROOT.CIMV2 {

  class StdRegProv {

    private static var CreatedClassName: String = 'StdRegProv';

    public static function CreateKey(hDefKey: uint, sSubKeyName: String): uint {
      var stackTrace: StackTrace = new StackTrace();
      var methodName: String = Util.GetMethodName(stackTrace);
      var classObj: ManagementClass = new ManagementClass(CreatedClassName);
      var inParams: ManagementBaseObject = classObj.GetMethodParameters(methodName);
      inParams['hDefKey'] = hDefKey;
      inParams['sSubKeyName'] = sSubKeyName;
      return Convert.ToUInt32(classObj.InvokeMethod(methodName, inParams, null).Properties['ReturnValue'].Value);
    }

    public static function DeleteKey(hDefKey: uint, sSubKeyName: String): uint {
      var stackTrace: StackTrace = new StackTrace();
      var methodName: String = Util.GetMethodName(stackTrace);
      var classObj: ManagementClass = new ManagementClass(CreatedClassName);
      var inParams: ManagementBaseObject = classObj.GetMethodParameters(methodName);
      inParams['hDefKey'] = hDefKey;
      inParams['sSubKeyName'] = sSubKeyName;
      return Convert.ToUInt32(classObj.InvokeMethod(methodName, inParams, null).Properties['ReturnValue'].Value);
    }

    public static function DeleteValue(hDefKey: uint, sSubKeyName: String, sValueName: String): uint {
      var stackTrace: StackTrace = new StackTrace();
      var methodName: String = Util.GetMethodName(stackTrace);
      var classObj: ManagementClass = new ManagementClass(CreatedClassName);
      var inParams: ManagementBaseObject = classObj.GetMethodParameters(methodName);
      inParams['hDefKey'] = hDefKey;
      inParams['sSubKeyName'] = sSubKeyName;
      inParams['sValueName'] = sValueName;
      return Convert.ToUInt32(classObj.InvokeMethod(methodName, inParams, null).Properties['ReturnValue'].Value);
    }

    public static function EnumKey(hDefKey: uint, sSubKeyName: String): String[] {
      var stackTrace: StackTrace = new StackTrace();
      var methodName: String = Util.GetMethodName(stackTrace);
      var classObj: ManagementClass = new ManagementClass(CreatedClassName);
      var inParams: ManagementBaseObject = classObj.GetMethodParameters(methodName);
      inParams['hDefKey'] = hDefKey;
      inParams['sSubKeyName'] = sSubKeyName;
      return classObj.InvokeMethod(methodName, inParams, null).Properties['sNames'].Value;
    }

    public static function GetStringValue(hDefKey: uint, sSubKeyName: String, sValueName: String): String {
      var stackTrace: StackTrace = new StackTrace();
      var methodName: String = Util.GetMethodName(stackTrace);
      var classObj: ManagementClass = new ManagementClass(CreatedClassName);
      var inParams: ManagementBaseObject = classObj.GetMethodParameters(methodName);
      inParams['hDefKey'] = hDefKey;
      inParams['sSubKeyName'] = sSubKeyName;
      inParams['sValueName'] = sValueName;
      return classObj.InvokeMethod(methodName, inParams, null).Properties['sValue'].Value;
    }

    public static function SetStringValue(hDefKey: uint, sSubKeyName: String, sValueName: String, sValue: String): String {
      var stackTrace: StackTrace = new StackTrace();
      var methodName: String = Util.GetMethodName(stackTrace);
      var classObj: ManagementClass = new ManagementClass(CreatedClassName);
      var inParams: ManagementBaseObject = classObj.GetMethodParameters(methodName);
      inParams['hDefKey'] = hDefKey;
      inParams['sSubKeyName'] = sSubKeyName;
      inParams['sValueName'] = sValueName;
      inParams['sValue'] = sValue;
      return Convert.ToUInt32(classObj.InvokeMethod(methodName, inParams, null).Properties['ReturnValue'].Value);
    }

    /**
     * Remove the key and all descendant subkeys.
     * @borrows DeleteKey as DeleteAllKey
     */
    public static function DeleteAllKey(hDefKey: uint, sSubKeyName: String): uint {
      var returnValue: uint = 0;
      var sNames = EnumKey(hDefKey, sSubKeyName);
      if (sNames != null) {
        for (var index = 0; index < sNames.length; index++) {
          returnValue += DeleteAllKey(hDefKey, sSubKeyName + '\\' + sNames[index]);
        }
      }
      return (returnValue += DeleteKey(hDefKey, sSubKeyName));
    }
  }

  internal class Util {

    /**
     * Get the name of the method calling this method.
     * NOTE: the method should initialize the stackTrace variable in its scope
     * before calling GetMethodName. So avoid GetMethodName(new stackTrace()).
     * @param stackTrace is the stack trace from the calling method.
     */
    public static function GetMethodName(stackTrace: StackTrace): String {
      return stackTrace.GetFrame(0).GetMethod().Name;
    }
  }
}

package ROOT.CIMV2.WIN32 {

  class Process {

    /**
     * The signature of the original Win32_Process.Create()
     * method is shortened and use-case specific.
     */
    public static function Create(CommandLine: String): uint {
      var stackTrace: StackTrace = new StackTrace();
      var methodName: String = Util.GetMethodName(stackTrace);
      var classObj: ManagementClass = new ManagementClass('Win32_Process');
      var inParams: ManagementBaseObject = classObj.GetMethodParameters(methodName);
      inParams['CommandLine'] = CommandLine;
      inParams['ProcessStartupInformation'] = ProcessStartup.CreateInstance();
      return Convert.ToUInt32(classObj.InvokeMethod(methodName, inParams, null).Properties['ProcessId'].Value);
    }
  }

  class ProcessStartup {

    public static function CreateInstance(): ManagementBaseObject {
      var startInfo: ManagementBaseObject = (new ManagementClass('Win32_ProcessStartup')).CreateInstance();
      startInfo['ShowWindow'] = 0;
      return startInfo;
    }
  }

  internal class Util {

    public static function GetMethodName(stackTrace: StackTrace): String {
      return stackTrace.GetFrame(0).GetMethod().Name;
    }
  }
}
